import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
from matplotlib.container import ErrorbarContainer
from matplotlib.ticker import AutoMinorLocator
from matplotlib.legend_handler import HandlerLine2D, HandlerErrorbar
import matplotlib.lines as mlines
from scipy.interpolate import interp1d

my_blue = (0.368417, 0.506779, 0.709798)
my_green = (0.280264, 0.715, 0.4292089322474965)
my_orange = (0.560181, 0.691569, 0.194885)

hbarc = 0.1973  # GeV*fm
start_point, stop_point, dr_spacing = 0.05, 2.1, 800
x = np.linspace(start_point, stop_point, dr_spacing)
a_W = 0.093   # fm
r0_a_W = 5.405

def add_errors(error1, error2):
    return np.sqrt(error1 ** 2 + error2 ** 2)


def calculate_error(value1, error1, value2, error2, operation):
    if operation == 'add':
        result = value1 + value2
        result_error = np.sqrt(error1 ** 2 + error2 ** 2)
    elif operation == 'subtract':
        result = value1 - value2
        result_error = np.sqrt(error1 ** 2 + error2 ** 2)
    elif operation == 'sqrt':
        result = value1 ** 0.5
        result_error = error1 / (2 * result)
        value2, error2 = 0, 0
    elif operation == 'multiply':
        result = value1 * value2
        relative_error_squared = (error1 / value1) ** 2 + (error2 / value2) ** 2
        result_error = np.abs(result) * np.sqrt(relative_error_squared)
    elif operation == 'divide':
        result = value1 / value2
        relative_error_squared = (error1 / value1) ** 2 + (error2 / value2) ** 2
        result_error = np.abs(result) * np.sqrt(relative_error_squared)
    else:
        raise ValueError("Operation must be 'multiply' or 'divide'")
    return result, result_error


def initial_parameters(r_values, data, data_errors):
    def potential(x_values, s, k, e):
        potential_function = np.zeros(len(data))
        for i in range(len(data)):
            potential_function[i] = s * x_values[i] + k / x_values[i] + e
        return potential_function
    parameters, covariance = curve_fit(potential, r_values, data, sigma=data_errors, p0=[0.99, -0.28, 0.2])
    errors = np.sqrt(np.diag(covariance))
    return parameters[0], parameters[1], parameters[2], errors[0], errors[1], errors[2]


def rescale_Bicudo(Bicudos, scale, scale_error, shift, shift_error):
    Bicudos[:, 0] /= scale
    Bicudos[:, 2], Bicudos[:, 3] = calculate_error(Bicudos[:, 2], Bicudos[:, 3], scale, scale_error, 'multiply')
    Bicudos[:, 2], Bicudos[:, 3] = calculate_error(Bicudos[:, 2], Bicudos[:, 3], shift, shift_error, 'add')
    return Bicudos


# Lattice data:
# Wagner SW:
r_SW_A = np.array([0.1863, 0.2794, 0.3726, 0.4657, 0.5589]) / 0.5
r_SW_B = np.array([0.1201, 0.1801, 0.2402, 0.3002, 0.3603]) / 0.5
r_SW_C = np.array([0.0960, 0.1441, 0.1921, 0.2401, 0.2881]) / 0.5
r_SW_D = np.array([0.0800, 0.1200, 0.1600, 0.2000, 0.2400, 0.2800]) / 0.5
r_SW_HYP2 = np.array([0.1863, 0.2794, 0.3726, 0.4657, 0.5589, 0.6520, 0.7452, 0.8383, 0.9315, 1.0246, 1.1178]) / 0.5

r_SW = np.concatenate([r_SW_A, r_SW_B, r_SW_C, r_SW_D, r_SW_HYP2], axis=0)
# data:
Sigma_gp_SW_A = np.array([-0.1033, 0.0929, 0.2428, 0.3726, 0.4919]) * 0.5 / hbarc
Sigma_gp_SW_B = np.array([-0.3254, -0.1227,  0.0174, 0.1292, 0.2256]) * 0.5 / hbarc
Sigma_gp_SW_C = np.array([-0.4459, -0.2326, -0.0910, 0.0176, 0.1079]) * 0.5 / hbarc
Sigma_gp_SW_D = np.array([-0.5520, -0.3260, -0.1796, -0.0706, 0.0176, 0.0930]) * 0.5 / hbarc
Sigma_gp_SW_HYP2 = np.array([-0.1112, 0.0928, 0.2430, 0.3727, 0.4923, 0.6059, 0.7159, 0.8240, 0.9308, 1.0351, 1.1345]) * 0.5 / hbarc

Sigma_gp_SW = np.concatenate([Sigma_gp_SW_A, Sigma_gp_SW_B, Sigma_gp_SW_C, Sigma_gp_SW_D, Sigma_gp_SW_HYP2], axis=0)

Pi_u_SW_A = np.array([1.2245, 1.2122, 1.2169, 1.2372, 1.2703]) * 0.5 / hbarc
Pi_u_SW_B = np.array([1.2318, 1.2127, 1.2039, 1.2035, 1.2067]) * 0.5 / hbarc
Pi_u_SW_C = np.array([1.2489, 1.2241, 1.2082, 1.2015, 1.1999]) * 0.5 / hbarc
Pi_u_SW_D = np.array([1.2754, 1.2497, 1.2337, 1.2234, 1.2173, 1.2148]) * 0.5 / hbarc
Pi_u_SW_HYP2 = np.array([1.2267, 1.2126, 1.2178, 1.2364, 1.2654, 1.3045, 1.3538, 1.4148, 1.4757, 1.5407, 1.6090]) * 0.5 / hbarc

Sigma_um_SW_A = np.array([1.2541, 1.2903, 1.3454, 1.4131, 1.4876]) * 0.5 / hbarc
Sigma_um_SW_B = np.array([1.2465, 1.2521, 1.2719, 1.3061, 1.3449]) * 0.5 / hbarc
Sigma_um_SW_C = np.array([1.2525, 1.2472, 1.2551, 1.2737, 1.2968]) * 0.5 / hbarc
Sigma_um_SW_D = np.array([1.2776, 1.2653, 1.2655, 1.2753, 1.2888, 1.3088]) * 0.5 / hbarc
Sigma_um_SW_HYP2 = np.array([1.2573, 1.2904, 1.3430, 1.4102, 1.4822, 1.5588, 1.6467, 1.7273, 1.8153, 1.9104, 2.0026]) * 0.5 / hbarc

Pi_u_SW = np.concatenate([Pi_u_SW_A, Pi_u_SW_B, Pi_u_SW_C, Pi_u_SW_D, Pi_u_SW_HYP2], axis=0)
Sigma_um_SW = np.concatenate([Sigma_um_SW_A, Sigma_um_SW_B, Sigma_um_SW_C, Sigma_um_SW_D, Sigma_um_SW_HYP2], axis=0)
# errors:
Sigma_gp_SW_errors_A = np.array([0.0024, 0.0024, 0.0024, 0.0024, 0.0025]) * 0.5 / hbarc
Sigma_gp_SW_errors_B = np.array([0.0026, 0.0024, 0.0024, 0.0024, 0.0024]) * 0.5 / hbarc
Sigma_gp_SW_errors_C = np.array([0.0028, 0.0024, 0.0024, 0.0024, 0.0024]) * 0.5 / hbarc
Sigma_gp_SW_errors_D = np.array([0.0030, 0.0025, 0.0024, 0.0024, 0.0024, 0.0024]) * 0.5 / hbarc
Sigma_gp_SW_errors_HYP2 = np.array([0.0024, 0.0023, 0.0024, 0.0024, 0.0026, 0.0028, 0.0032, 0.0037, 0.0044, 0.0054, 0.0069]) * 0.5 / hbarc

Pi_u_SW_errors_A = np.array([0.0073, 0.0076, 0.0078, 0.0081, 0.0084]) * 0.5 / hbarc
Pi_u_SW_errors_B = np.array([0.0150, 0.0149, 0.0147, 0.0147, 0.0270]) * 0.5 / hbarc
Pi_u_SW_errors_C = np.array([0.0168, 0.0165, 0.0159, 0.0095, 0.0093]) * 0.5 / hbarc
Pi_u_SW_errors_D = np.array([0.0103, 0.0109, 0.0106, 0.0104, 0.0101, 0.0099]) * 0.5 / hbarc
Pi_u_SW_errors_HYP2 = np.array([0.0058, 0.0056, 0.0058, 0.0061, 0.0066, 0.0072, 0.0079, 0.0074, 0.0079, 0.0085, 0.0091]) * 0.5 / hbarc

Sigma_um_SW_errors_A = np.array([0.0076, 0.0091, 0.0108, 0.0127, 0.0154]) * 0.5 / hbarc
Sigma_um_SW_errors_B = np.array([0.0170, 0.0183, 0.0199, 0.0220, 0.0246]) * 0.5 / hbarc
Sigma_um_SW_errors_C = np.array([0.0180, 0.0108, 0.0112, 0.0116, 0.0122]) * 0.5 / hbarc
Sigma_um_SW_errors_D = np.array([0.0113, 0.0116, 0.0118, 0.0122, 0.0127, 0.0133]) * 0.5 / hbarc
Sigma_um_SW_errors_HYP2 = np.array([0.0051, 0.0051, 0.0053, 0.0054, 0.0052, 0.0052, 0.0053, 0.0054, 0.0055, 0.0058, 0.0061]) * 0.5 / hbarc

Sigma_gp_SW_errors = np.concatenate([Sigma_gp_SW_errors_A, Sigma_gp_SW_errors_B, Sigma_gp_SW_errors_C, Sigma_gp_SW_errors_D, Sigma_gp_SW_errors_HYP2], axis=0)
Pi_u_SW_errors = np.concatenate([Pi_u_SW_errors_A, Pi_u_SW_errors_B, Pi_u_SW_errors_C, Pi_u_SW_errors_D, Pi_u_SW_errors_HYP2], axis=0)
Sigma_um_SW_errors = np.concatenate([Sigma_um_SW_errors_A, Sigma_um_SW_errors_B, Sigma_um_SW_errors_C, Sigma_um_SW_errors_D, Sigma_um_SW_errors_HYP2], axis=0)

# Wagner CPRRW:
r_CPRRW = np.arange(2, 13) / r0_a_W
lattice_error = np.array([0.03529478, 0.03967817, 0.04055326, 0.04098092, 0.04207778, 0.0424421, 0.04290145, 0.04451903, 0.04530903, 0.04651875, 0.04801358])
HYP2_self_energy = 0.340
HYP2_self_energy_error = 0.002
# data:
Pi_u_CPRRW = np.array([0.7427, 0.7369, 0.7395, 0.7483, 0.7621, 0.7805, 0.8037, 0.8326, 0.8613, 0.892, 0.9243]) * r0_a_W - HYP2_self_energy * (0.5/hbarc) - lattice_error
Sigma_um_CPRRW = np.array([1.2573, 1.2904, 1.3430, 1.4102, 1.4822, 1.5588, 1.6467, 1.7273, 1.8153, 1.9104, 2.0026]) * r0_a_W - HYP2_self_energy * (0.5/hbarc) - lattice_error
Sigma_gp_prime_CPRRW = np.array([0.902, 0.9023, 0.9155, 0.9289, 0.9465, 0.9689, 0.994, 1.0249, 1.0489, 1.0834, 1.1056]) * r0_a_W - HYP2_self_energy * (0.5/hbarc) - lattice_error
Delta_g_CPRRW = np.array([0.99183, 0.98505, 0.98451, 0.9863, 0.9947, 1.00777, 1.0232, 1.04199, 1.06294, 1.0865, 1.1072]) * r0_a_W - HYP2_self_energy * (0.5/hbarc) - lattice_error
Sigma_gm_CPRRW = np.array([1.0066, 1.0068, 1.0155, 1.0285, 1.0468, 1.07, 1.0975, 1.1282, 1.161, 1.1971, 1.235]) * r0_a_W - HYP2_self_energy * (0.5/hbarc) - lattice_error
Pi_g_CPRRW = np.array([0.9425, 0.9585, 0.9796, 0.996, 1.0086, 1.0216, 1.0355, 1.0528, 1.0628, 1.0837, 1.1098]) * r0_a_W - HYP2_self_energy * (0.5/hbarc) - lattice_error
# errors:
Sigma_gp_CPRRW_errors = np.array([0.000013, 0.000031, 0.000061, 0.00012, 0.00019, 0.00029, 0.00045, 0.00068, 0.0011, 0.0016, 0.0024]) * r0_a_W
Pi_u_CPRRW_errors = np.array([0.0022, 0.0019, 0.0018, 0.0018, 0.0020, 0.0022, 0.0025, 0.0016, 0.0019, 0.0023, 0.0028]) * r0_a_W
Sigma_um_CPRRW_errors = np.array([0.0051, 0.0051, 0.0053, 0.0054, 0.0052, 0.0052, 0.0053, 0.0054, 0.0055, 0.0058, 0.0061]) * r0_a_W
Sigma_gp_prime_CPRRW_errors = np.array([0.0030, 0.0028, 0.0014, 0.0014, 0.0031, 0.0034, 0.0040, 0.0019, 0.0055, 0.0026, 0.0081]) * r0_a_W
Delta_g_CPRRW_errors = np.array([0.00088, 0.00083, 0.00078, 0.0017, 0.0017, 0.00078, 0.00081, 0.00086, 0.00092, 0.0011, 0.0028]) * r0_a_W
Sigma_gm_CPRRW_errors = np.array([0.00075, 0.00081, 0.00090, 0.0011, 0.00063, 0.00072, 0.00081, 0.00094, 0.0011, 0.0013, 0.0015]) * r0_a_W
Pi_g_CPRRW_errors = np.array([0.0017, 0.0017, 0.0018, 0.0019, 0.0019, 0.0020, 0.0021, 0.0024, 0.0068, 0.0081, 0.0099]) * r0_a_W


# Data Bicudo:
# key: [0 r, 1 err_r, 2 v, 3 err_v, 4 xi^2/Nf, 5 ri, 6 rf]
Sigma_gp_BCS_S4 = np.array([
    [0.30431904222043743, 0.00032220378975774164, -0.4089584622395938, 0.005536204408772946, 0.7586507005466374, 14.0, 23.0],
    [0.6086380844408749, 0.0006444075795154833, 0.2538487145610721, 0.005525940040855921, 0.4285128787527217, 16.0, 23.0],
    [0.9129571266613123, 0.0009666113692732248, 0.7448495366900016, 0.005577705049627467, 0.865938076484484, 15.0, 23.0],
    [1.2172761688817497, 0.0012888151590309666, 1.1245174446089505, 0.005651628161783749, 0.613536917993028, 14.0, 23.0],
    [1.521595211102187, 0.0016110189487887083, 1.4673004465455253, 0.005763417531961827, 0.8204690495018164, 14.0, 23.0],
    [1.8259142533226247, 0.0019332227385464495, 1.7935328623742481, 0.005886399394877732, 0.7025229749859266, 14.0, 23.0],
    [2.130233295543062, 0.0022554265283041917, 2.113592431550762, 0.006003302852984074, 0.5482006669139355, 11.0, 17.0],
    [2.4345523377634994, 0.002577630318061933, 2.426953249428143, 0.006141099748855663, 0.4601918225037828, 11.0, 18.0],
    [2.738871379983937, 0.0028998341078196746, 2.7389725556920834, 0.006471971064906022, 0.8640727192242221, 10.0, 21.0],
    [3.043190422204374, 0.0032220378975774166, 3.042178785278884, 0.006900749424864667, 1.0674021043505013, 11.0, 22.0],
    [3.3475094644248116, 0.003544241687335158, 3.349445737226461, 0.007268715859183861, 0.6007409515236698, 10.0, 20.0],
    [3.6518285066452494, 0.003866445477092899, 3.65099268735711, 0.007455482227418046, 0.37872355824105636, 10.0, 21.0]
])
Sigma_gp_BCS_W1 = np.array([
    [3.13426922e-01, 2.42924188e-04, -7.11993041e-01, 2.27912286e-03, 5.01353701e-01, 5.00000000e+00, 1.70000000e+01],
    [4.70140383e-01, 3.64386283e-04, -2.14174039e-01, 2.21882502e-03, 3.07767049e-01, 5.00000000e+00, 1.70000000e+01],
    [6.26853844e-01, 4.85848377e-04, 1.13105342e-01, 2.23116322e-03, 5.91496528e-01, 5.00000000e+00, 1.70000000e+01],
    [7.83567305e-01, 6.07310471e-04, 3.71553807e-01, 2.27495013e-03, 6.38860945e-01, 5.00000000e+00, 1.70000000e+01],
    [9.40280766e-01, 7.28772565e-04, 5.96965179e-01, 2.30532308e-03, 5.20104892e-01, 4.00000000e+00, 1.70000000e+01],
    [1.09699423e+00, 8.50234660e-04, 8.02492969e-01, 2.31197936e-03, 2.77821360e-01, 4.00000000e+00, 1.70000000e+01],
    [1.25370769e+00, 9.71696754e-04, 9.96516515e-01, 2.37595851e-03, 2.94346235e-01, 4.00000000e+00, 1.70000000e+01],
    [1.41042115e+00, 1.09315885e-03, 1.18156152e+00, 2.45865161e-03, 1.77348337e-01, 4.00000000e+00, 1.60000000e+01],
    [1.56713461e+00, 1.21462094e-03, 1.36164982e+00, 2.67800403e-03, 2.42867434e-01, 4.00000000e+00, 1.60000000e+01],
    [1.72384807e+00, 1.33608304e-03, 1.53816880e+00, 2.98824174e-03, 5.32773349e-01, 4.00000000e+00, 1.50000000e+01],
    [1.88056153e+00, 1.45754513e-03, 1.71158205e+00, 3.56936460e-03, 7.07868407e-01, 4.00000000e+00, 1.50000000e+01]
])
Sigma_gp_BCS_W2 = np.array([
    [3.09337370e-01, 2.00102749e-04, -2.22801425e-01, 3.96448356e-03, 8.34481144e-01, 8.00000000e+00, 2.30000000e+01],
    [6.18674741e-01, 4.00205498e-04, 3.30259092e-01, 3.96824790e-03, 6.17209852e-01, 9.00000000e+00, 2.30000000e+01],
    [9.28012111e-01, 6.00308247e-04, 7.95231665e-01, 4.00056334e-03, 9.02777555e-01, 8.00000000e+00, 2.20000000e+01],
    [1.23734948e+00, 8.00410996e-04, 1.17236183e+00, 4.05919063e-03, 8.19897756e-01, 7.00000000e+00, 2.30000000e+01],
    [1.54668685e+00, 1.00051375e-03, 1.51440007e+00, 4.10955589e-03, 7.02112994e-01, 7.00000000e+00, 1.90000000e+01],
    [1.85602422e+00, 1.20061649e-03, 1.84129592e+00, 4.15974944e-03, 3.10747783e-01, 7.00000000e+00, 9.00000000e+00],
    [2.16536159e+00, 1.40071924e-03, 2.15851905e+00, 4.28450782e-03, 8.80110634e-01, 7.00000000e+00, 1.00000000e+01],
    [2.47469896e+00, 1.60082199e-03, 2.47411990e+00, 4.50413941e-03, 5.20669261e-01, 5.00000000e+00, 1.40000000e+01],
    [2.78403633e+00, 1.80092474e-03, 2.78464978e+00, 4.45851708e-03, 3.30071297e-01, 5.00000000e+00, 1.40000000e+01],
    [3.09337370e+00, 2.00102749e-03, 3.09274417e+00, 4.66141819e-03, 2.11548130e-01, 5.00000000e+00, 1.40000000e+01],
    [3.40271107e+00, 2.20113024e-03, 3.40263475e+00, 4.57257543e-03, 1.99806529e-01, 5.00000000e+00, 1.20000000e+01],
    [3.71204844e+00, 2.40123299e-03, 3.71683714e+00, 7.31966261e-03, 7.68947059e-01, 4.00000000e+00, 1.10000000e+01]
])
Sigma_gp_BCS_W4 = np.array([
    [4.98613969e-01, 3.83961427e-04, 2.50340844e-01, 5.84375457e-03, 2.60589121e-01, 20, 23],
    [9.97227939e-01, 7.67922854e-04, 8.74782876e-01, 5.88010595e-03, 9.56282122e-01, 18, 23],
    [1.49584191e+00, 1.15188428e-03, 1.45326025e+00, 5.95960738e-03, 7.74130724e-01, 17, 23],
    [1.99445588e+00, 1.53584571e-03, 1.98086198e+00, 6.07011097e-03, 9.54484329e-01, 14, 23],
    [2.49306985e+00, 1.91980714e-03, 2.48548203e+00, 6.25982373e-03, 5.40008674e-01, 14, 23],
    [2.99168382e+00, 2.30376856e-03, 2.99105169e+00, 6.69394509e-03, 3.64295578e-01, 11, 20],
    [3.49029779e+00, 2.68772999e-03, 3.48785988e+00, 8.26958732e-03, 1.01867032e+00, 11, 21],
    [3.98891176e+00, 3.07169142e-03, 3.99096845e+00, 7.05183926e-03, 6.02464546e-01, 9, 19],
    [4.48752572e+00, 3.45565284e-03, 4.48767544e+00, 1.37984656e-02, 7.21483435e-01, 8, 18],
    [4.98613969e+00, 3.83961427e-03, 4.97233662e+00, 1.36999594e-02, 5.51442234e-01, 8, 15],
    [5.48475366e+00, 4.22357570e-03, 5.49287092e+00, 2.33562735e-02, 6.02209641e-01, 7, 14],
    [5.98336763e+00, 4.60753713e-03, 5.98186426e+00, 9.45797846e-03, 3.23760600e-01, 7, 14]
])
Sigma_gp_BCS_S4_reduced = np.array([
    [0.6086380844408749, 0.0006444075795154833, 0.2538487145610721, 0.005525940040855921, 0.4285128787527217, 16.0, 23.0],
    [0.9129571266613123, 0.0009666113692732248, 0.7448495366900016, 0.005577705049627467, 0.865938076484484, 15.0, 23.0],
    [1.2172761688817497, 0.0012888151590309666, 1.1245174446089505, 0.005651628161783749, 0.613536917993028, 14.0, 23.0],
    [1.521595211102187, 0.0016110189487887083, 1.4673004465455253, 0.005763417531961827, 0.8204690495018164, 14.0, 23.0],
    [1.8259142533226247, 0.0019332227385464495, 1.7935328623742481, 0.005886399394877732, 0.7025229749859266, 14.0, 23.0],
    [2.130233295543062, 0.0022554265283041917, 2.113592431550762, 0.006003302852984074, 0.5482006669139355, 11.0, 17.0]
])
Sigma_gp_BCS_W1_reduced = np.array([
    [6.26853844e-01, 4.85848377e-04, 1.13105342e-01, 2.23116322e-03, 5.91496528e-01, 5.00000000e+00, 1.70000000e+01],
    [7.83567305e-01, 6.07310471e-04, 3.71553807e-01, 2.27495013e-03, 6.38860945e-01, 5.00000000e+00, 1.70000000e+01],
    [9.40280766e-01, 7.28772565e-04, 5.96965179e-01, 2.30532308e-03, 5.20104892e-01, 4.00000000e+00, 1.70000000e+01],
    [1.09699423e+00, 8.50234660e-04, 8.02492969e-01, 2.31197936e-03, 2.77821360e-01, 4.00000000e+00, 1.70000000e+01],
    [1.25370769e+00, 9.71696754e-04, 9.96516515e-01, 2.37595851e-03, 2.94346235e-01, 4.00000000e+00, 1.70000000e+01],
    [1.41042115e+00, 1.09315885e-03, 1.18156152e+00, 2.45865161e-03, 1.77348337e-01, 4.00000000e+00, 1.60000000e+01],
    [1.56713461e+00, 1.21462094e-03, 1.36164982e+00, 2.67800403e-03, 2.42867434e-01, 4.00000000e+00, 1.60000000e+01],
    [1.72384807e+00, 1.33608304e-03, 1.53816880e+00, 2.98824174e-03, 5.32773349e-01, 4.00000000e+00, 1.50000000e+01],
    [1.88056153e+00, 1.45754513e-03, 1.71158205e+00, 3.56936460e-03, 7.07868407e-01, 4.00000000e+00, 1.50000000e+01]
])
Sigma_gp_BCS_W2_reduced = np.array([
    [6.18674741e-01, 4.00205498e-04, 3.30259092e-01, 3.96824790e-03, 6.17209852e-01, 9.00000000e+00, 2.30000000e+01],
    [9.28012111e-01, 6.00308247e-04, 7.95231665e-01, 4.00056334e-03, 9.02777555e-01, 8.00000000e+00, 2.20000000e+01],
    [1.23734948e+00, 8.00410996e-04, 1.17236183e+00, 4.05919063e-03, 8.19897756e-01, 7.00000000e+00, 2.30000000e+01],
    [1.54668685e+00, 1.00051375e-03, 1.51440007e+00, 4.10955589e-03, 7.02112994e-01, 7.00000000e+00, 1.90000000e+01],
    [1.85602422e+00, 1.20061649e-03, 1.84129592e+00, 4.15974944e-03, 3.10747783e-01, 7.00000000e+00, 9.00000000e+00],
    [2.16536159e+00, 1.40071924e-03, 2.15851905e+00, 4.28450782e-03, 8.80110634e-01, 7.00000000e+00, 1.00000000e+01]
])
Sigma_gp_BCS_W4_reduced = np.array([
    [4.98613969e-01, 3.83961427e-04, 2.50340844e-01, 5.84375457e-03, 2.60589121e-01, 20, 23],
    [9.97227939e-01, 7.67922854e-04, 8.74782876e-01, 5.88010595e-03, 9.56282122e-01, 18, 23],
    [1.49584191e+00, 1.15188428e-03, 1.45326025e+00, 5.95960738e-03, 7.74130724e-01, 17, 23],
    [1.99445588e+00, 1.53584571e-03, 1.98086198e+00, 6.07011097e-03, 9.54484329e-01, 14, 23]
])
Sigma_gp_prime_BCS_S4 = np.array([
    [0.30431904222043743, 0.00032220378975774164, 3.45291201607496,    0.008882556614326435, 0.2505407836812401,  13, 17],
    [0.6086380844408749,  0.0006444075795154833,  3.4561525326931064, 0.011297232298596504, 0.6752867899220533,  13, 19],
    [0.9129571266613123,  0.0009666113692732248,  3.5377743780120237, 0.016465302723151345, 0.999667546513564,   13, 20],
    [1.2172761688817497,  0.0012888151590309666,  3.628832473390912,  0.014775842429622052, 0.7133272637882596, 14, 19],
    [1.521595211102187,   0.0016110189487887083,  3.782732825907669,  0.021005251586043074, 0.9244990123183109, 13, 20],
    [1.8259142533226247,  0.0019332227385464495,  3.924758540791748,  0.020629800207800995, 0.8531451632896732, 13, 20],
    [2.130233295543062,   0.0022554265283041917,  4.156335785353068,  0.012269021942943428, 0.7729691609731559, 11, 13],
    [2.4345523377634994,  0.002577630318061933,   4.332647238337186,  0.011759927972485115, 0.4646119424738568, 11, 13],
    [2.738871379983937,   0.0028998341078196746,  4.518038299977445,  0.021914865722423394, 1.0704779021091468, 11, 17],
    [3.043190422204374,   0.0032220378975774166,  4.720944137605678,  0.02665936061609828,  0.5780705047669794, 11, 16],
    [3.3475094644248116,  0.003544241687335158,   4.962831352421696,  0.015546024297548103, 0.6140234201861685, 10, 11]
])
Sigma_gp_prime_BCS_W1 = np.array([
    [0.313426922117816,   0.00024292418845237593, 3.469367301050456,   0.012100595096981795, 0.803454963575834,   4, 5],
    [0.47014038317672396, 0.0003643862826785639,  3.4499070583002633, 0.004528948298048461,  0.486422518123868,   4, 8],
    [0.626853844235632,   0.00048584837690475186, 3.4682066980378674, 0.007135332652943809,  0.49864104348566113, 4, 9],
    [0.78356730529454,    0.0006073104711309398,  3.5045282652250456, 0.011800400867324558,  0.5778391221139324,  4, 9],
    [0.9402807663534479,  0.0007287725653571278,  3.5556048774875797, 0.013274036210481075,  0.5298819447299976,  4, 9],
    [1.0969942274123559,  0.0008502346595833157,  3.612538834597699,  0.01308214796050538,   0.2486583218276434,  4, 9],
    [1.253707688471264,   0.0009716967538095037,  3.679575909178993,  0.01944427885737009,   0.5923942994452707,  4, 9],
    [1.410421149530172,   0.0010931588480356917,  3.7458391200632435, 0.02374383096400002,   0.5662368486168289,  4, 9],
    [1.56713461058908,    0.0012146209422618797,  3.815565177557528,  0.018193553193068108,  0.4537787897163513,  4, 9],
    [1.7238480716479878,  0.0013360830364880676,  3.890382838334036,  0.026124228023753446,  1.1193805973741768,  4, 9],
    [1.8805615327068959,  0.0014575451307142556,  3.9806133843040405, 0.029403278285204018,  1.2235920270718816,  4, 8]
])
Sigma_gp_prime_BCS_W2 = np.array([
    [0.30933737031744996, 0.00020010274906899825, 3.334097607815643,   0.015020070331181842, 0.3184494344202798,   9, 12],
    [0.6186747406348999,  0.0004002054981379965,  3.3237812900454067, 0.022102599726026694, 0.5667534743518722,   9, 12],
    [0.9280121109523498,  0.0006003082472069946,  3.4429791716806704, 0.02267884465163478,  1.074802166644225,    8, 14],
    [1.2373494812697998,  0.000800410996275993,   3.585224603167537,  0.010951834990724742, 0.85496178406636,     7, 9],
    [1.5466868515872498,  0.0010005137453449912,  3.7325657011870104, 0.008847911534796717,  0.9226226118827605,  6, 12],
    [1.8560242219046996,  0.0012006164944139892,  3.8846355938806956, 0.009456243639291064,  0.8429000396998761,  6, 12],
    [2.16536159222215,    0.0014007192434829878,  4.020309760026531,  0.01210961067701289,   0.1802126882741323,  8, 9],
    [2.4746989625395996,  0.001600821992551986,   4.256645879415291,  0.010465221593583537,  1.1852769574254054,  6, 9],
    [2.7840363328570494,  0.001800924741620984,   4.465860875906445,  0.011616664090966004,  1.0669857253914985,  5, 9],
    [3.0933737031744997,  0.0020010274906899824,  4.64194653737364,   0.030158468338381088,  1.1212920815191567,  6, 11],
    [3.4027110734919495,  0.0022011302397589804,  4.864618114511044,  0.027926166394825747,  1.160089261626394,   6, 10]
])
Sigma_gp_prime_BCS_W4 = np.array([
    [0.4986139693965455,   0.00038396142710761836, 3.314146700933338,   0.006412134094670953, 0.00160931929317,   11, 12],
    [0.997227938793091,    0.0007679228542152367,  3.3979554330227946,  0.009697616079798053, 0.322420912505,    11, 12],
    [1.4958419081896366,   0.0011518842813228551,  3.6233810455834203,  0.012551396599590979, 0.644421344683,    11, 12],
    [1.994455877586182,    0.0015358457084304734,  3.9031972302013376,  0.009493619653078461, 0.159725712106,    11, 12],
    [2.4930698469827277,   0.0019198071355380918,  4.1831826078647145,  0.02346143145586238,  0.854350313602,   11, 12],
    [2.991683816379273,    0.0023037685626457103,  4.5619573670082625,  0.01464830530612285,  0.75794974986,     9, 10],
    [3.4902977857758186,   0.0026877299897533286,  4.912202264991778,   0.018256272028292796, 0.536863471083,    9, 10],
    [3.988911755172364,    0.003071691416860947,   5.300240135376825,   0.025546548832434915, 1.27028112372,     8, 10],
    [4.4875257245689095,   0.003455652843968565,   5.653298641067148,   0.05078581580961612,  1.67937645977,     8, 10],
    [4.986139693965455,    0.0038396142710761835,  6.069592795711649,   0.08184739450521766,  1.84640999579,     8, 10],
    [5.484753663362,       0.004223575698183803,   6.568854111258887,   0.012095329992360014, 0.0394447513844,   7, 8]
])
Pi_u_BCS = np.array([
    [0.6086380844408749, 0.0006444075795154833, 2.818912212938907, 0.007062719817156888, 0.45402732797323403, 11.0, 23.0],
    [0.9129571266613123, 0.0009666113692732248, 2.8276242994323977, 0.007596975204330657, 0.3912022836794695, 11.0, 23.0],
    [1.2172761688817497, 0.0012888151590309666, 2.898710148941766, 0.007883548155687141, 0.9465677488637396, 11.0, 19.0],
    [1.521595211102187, 0.0016110189487887083, 3.0096594727926322, 0.007643885116585816, 0.5463954587518821, 11.0, 18.0],
    [1.8259142533226247, 0.0019332227385464495, 3.1636217825652313, 0.007556310504413822, 0.7637104767635958, 10.0, 22.0],
    [2.130233295543062, 0.0022554265283041917, 3.3502495854167744, 0.006868545139330805, 0.7252340217561097, 10.0, 22.0],
    [2.4345523377634994, 0.002577630318061933, 3.5592696411068596, 0.007067794423882008, 0.31825703753399553, 9.0, 22.0],
    [2.738871379983937, 0.0028998341078196746, 3.777005387523099, 0.007880644959550234, 0.5656069809897325, 9.0, 22.0],
    [3.043190422204374, 0.0032220378975774166, 4.007117283484843, 0.010963080798540923, 1.4699492414191042, 9.0, 21.0],
    [3.3475094644248116, 0.003544241687335158, 4.240380108663329, 0.010261588314850013, 0.9641340759484835, 9.0, 19.0],
    [3.6518285066452494, 0.003866445477092899, 4.480305830716259, 0.01075994064048647, 0.9396503643577707, 9.0, 18.0]
])
Sigma_um_BCS = np.array([
    [0.6086380844408749, 0.0006444075795154833, 2.988332795257054, 0.012584817413803481, 1.2987892415290183, 11.0, 20.0],
    [0.9129571266613123, 0.0009666113692732248, 3.1367105203529144, 0.011871240271442771, 0.7241747463760846, 11.0, 20.0],
    [1.2172761688817497, 0.0012888151590309666, 3.344899895629369, 0.01351317728778051, 1.0461962374981215, 11.0, 21.0],
    [1.521595211102187, 0.0016110189487887083, 3.5602043096310023, 0.01118881788777401, 1.2174172726182664, 11.0, 21.0],
    [1.8259142533226247, 0.0019332227385464495, 3.8288990193946284, 0.01863382638606688, 1.1597443229267863, 10.0, 20.0],
    [2.130233295543062, 0.0022554265283041917, 4.091290533588178, 0.011337521627846051, 0.7864058717276913, 9.0, 20.0],
    [2.4345523377634994, 0.002577630318061933, 4.385934205357102, 0.02013941040621097, 1.2023376658873255, 8.0, 19.0],
    [2.738871379983937, 0.0028998341078196746, 4.67654824849732, 0.016226765183133242, 1.1050344349109529, 8.0, 18.0],
    [3.043190422204374, 0.0032220378975774166, 4.9535095761893935, 0.008220891834445932, 0.10643574296546265, 8.0, 12.0],
    [3.3475094644248116, 0.003544241687335158, 5.266850559728159, 0.008469456761700422, 0.20125015078648611, 8.0, 12.0],
    [3.6518285066452494, 0.003866445477092899, 5.546938418691628, 0.013958361495772184, 0.2440916376512424, 8.0, 11.0]
])
Delta_g_BCS = np.array([
    [0.6086380844408749, 0.0006444075795154833, 3.9504603887652503, 0.009695580225823964, 0.9741085927217048, 8.0, 10.0],
    [0.9129571266613123, 0.0009666113692732248, 3.9256754236741633, 0.007741396435275587, 0.6305119179698573, 9.0, 11.0],
    [1.2172761688817497, 0.0012888151590309666, 3.964973026326093, 0.009072034924192285, 0.894413385153887, 8.0, 11.0],
    [1.521595211102187, 0.0016110189487887083, 4.020388373094156, 0.00814017790072229, 1.0387357006255948, 9.0, 12.0],
    [1.8259142533226247, 0.0019332227385464495, 4.123887811090997, 0.011069236179848155, 0.7600480374458569, 8.0, 19.0],
    [2.130233295543062, 0.0022554265283041917, 4.255489993801665, 0.009604726585748485, 0.6069875775467358, 8.0, 18.0],
    [2.4345523377634994, 0.002577630318061933, 4.410659720650215, 0.00947250307635315, 0.8568229116268431, 8.0, 16.0],
    [2.738871379983937, 0.0028998341078196746, 4.591496528608742, 0.012006878837717389, 1.0739093900335612, 8.0, 17.0],
    [3.043190422204374, 0.0032220378975774166, 4.794104585221281, 0.009393287845332405, 0.7559739077985922, 8.0, 17.0],
    [3.3475094644248116, 0.003544241687335158, 5.011985613561965, 0.008960226301646423, 0.5305772494957146, 8.0, 10.0],
    [3.6518285066452494, 0.003866445477092899, 5.236319516807992, 0.011490560064782482, 0.7250907953816113, 8.0, 16.0]
])
Sigma_gm_BCS = np.array([
    [0.6086380844408749, 0.0006444075795154833, 4.009308118537939, 0.012184575590835385, 0.7619240052794514, 9.0, 11.0],
    [0.9129571266613123, 0.0009666113692732248, 4.05234067523718, 0.012762345526622077, 0.6894919424775283, 9.0, 20.0],
    [1.2172761688817497, 0.0012888151590309666, 4.155075239735784, 0.0090481306709428, 0.7771998590375027, 9.0, 19.0],
    [1.521595211102187, 0.0016110189487887083, 4.291411163471889, 0.007879698831636774, 0.8557548571318229, 9.0, 15.0],
    [1.8259142533226247, 0.0019332227385464495, 4.459180720084817, 0.008402208704430486, 0.3336167184765883, 9.0, 15.0],
    [2.130233295543062, 0.0022554265283041917, 4.653980651138865, 0.011646590416287073, 0.9538244235656034, 9.0, 16.0],
    [2.4345523377634994, 0.002577630318061933, 4.875238939141648, 0.023612386059304838, 0.8346283265218762, 9.0, 17.0],
    [2.738871379983937, 0.0028998341078196746, 5.100607917939416, 0.03627718612689998, 0.8493434684152639, 9.0, 14.0],
    [3.043190422204374, 0.0032220378975774166, 5.379003287178278, 0.008545147707522951, 0.20639255247341162, 8.0, 14.0],
    [3.3475094644248116, 0.003544241687335158, 5.658507969117562, 0.03425920200748412, 0.45746143048015303, 8.0, 12.0],
    [3.6518285066452494, 0.003866445477092899, 5.963686727683614, 0.06609118934309657, 0.82052109928838, 8.0, 12.0]
])
Pi_g_BCS = np.array([
    [0.6086380844408749, 0.0006444075795154833, 3.7556668168743905, 0.021192139849868525, 0.40306738063715336, 12.0, 20.0],
    [0.9129571266613123, 0.0009666113692732248, 3.8236064428965695, 0.019479133798634786, 0.3220836843440656, 12.0, 17.0],
    [1.2172761688817497, 0.0012888151590309666, 3.9481651981645567, 0.017899586455178317, 0.7517336440763823, 10.0, 21.0],
    [1.521595211102187, 0.0016110189487887083, 4.023100125669836, 0.023406289287813253, 1.1380221175228817, 10.0, 18.0],
    [1.8259142533226247, 0.0019332227385464495, 4.118899773470307, 0.022803843125632384, 1.1167648409671573, 10.0, 20.0],
    [2.130233295543062, 0.0022554265283041917, 4.25870545542826, 0.02045699022360944, 1.187498731430154, 10.0, 12.0],
    [2.4345523377634994, 0.002577630318061933, 4.450111272692603, 0.009973558293881876, 0.7087192435686025, 8.0, 9.0],
    [2.738871379983937, 0.0028998341078196746, 4.586276961419723, 0.019731825346292472, 0.7122518114989255, 9.0, 17.0],
    [3.043190422204374, 0.0032220378975774166, 4.780689882778782, 0.017207257381141025, 0.8289638580677882, 8.0, 11.0],
    [3.3475094644248116, 0.003544241687335158, 4.980019837142291, 0.017481848402358783, 0.5086809658741921, 8.0, 11.0],
    [3.6518285066452494, 0.003866445477092899, 5.18715328543115, 0.018494866965834543, 0.4960830326539329, 8.0, 16.0]
])
Pi_g_prime_BCS = np.array([
    [0.6086380844408749, 0.0006444075795154833, 5.410304106405222, 0.04106682989646334, 0.7349281290354946, 9.0, 15.0],
    [0.9129571266613123, 0.0009666113692732248, 5.392218403843503, 0.021354697513460846, 0.9698906066341559, 9.0, 13.0],
    [1.2172761688817497, 0.0012888151590309666, 5.394065262219361, 0.026897637319758624, 0.8164387251206472, 9.0, 14.0],
    [1.521595211102187, 0.0016110189487887083, 5.434722074229251, 0.049524786939241894, 0.9060202785494925, 9.0, 15.0],
    [1.8259142533226247, 0.0019332227385464495, 5.50728694956974, 0.03512245398376334, 0.42367719901289597, 9.0, 15.0],
    [2.130233295543062, 0.0022554265283041917, 5.5736976152630575, 0.05626975867514915, 1.0194311673475074, 9.0, 15.0],
    [2.4345523377634994, 0.002577630318061933, 5.671872600722392, 0.06774707821517131, 1.0311950647712274, 9.0, 14.0],
    [2.738871379983937, 0.0028998341078196746, 5.899277948753114, 0.03708766940710486, 0.5251994445203193, 8.0, 14.0],
    [3.043190422204374, 0.0032220378975774166, 6.059799600365029, 0.035014158732296775, 0.5445053003939169, 8.0, 13.0],
    [3.3475094644248116, 0.003544241687335158, 6.216247018205934, 0.06242110885027276, 0.6756312518438536, 8.0, 13.0],
    [3.6518285066452494, 0.003866445477092899, 6.3606964348410715, 0.05983881657177061, 0.5483960341264303, 8.0, 11.0]
])

"""for i in Sigma_gp_BCS_S4[:, 0]:
    if (i > np.sqrt(0.18)/(4.3*hbarc)) and (i < 1.2*np.sqrt(0.18)/hbarc):
        print(i*hbarc/np.sqrt(0.18))"""
# Cornell Fit:
"""sigma0r0squared, kappa0, E0r0, sigma0r0squared_error, kappa0_error, E0r0_error = 1.3498, -0.2885, -0.0031, 0.0152, 0.0125, 0.0291

sigma0oversigma_W1, kappaB_W1, E0overSqrtsigma_W1, sigma0oversigma_W1_error, kappaB_W1_error, E0overSqrtsigma_W1_error = 1.0359, -0.2881, -0.0743, 0.0057, 0, 0.0008
sigma0oversigma_W2, kappaB_W2, E0overSqrtsigma_W2, sigma0oversigma_W2_error, kappaB_W2_error, E0overSqrtsigma_W2_error = 0.9924, -0.2881, 0.1689, 0.0068, 0, 0.0017
sigma0oversigma_W4, kappaB_W4, E0overSqrtsigma_W4, sigma0oversigma_W4_error, kappaB_W4_error, E0overSqrtsigma_W4_error = 0.9809, -0.2881, 0.2198, 0.0056, 0, 0.0027
sigma0oversigma_S4, kappaB_S4, E0overSqrtsigma_S4, sigma0oversigma_S4_error, kappaB_S4_error, E0overSqrtsigma_S4_error = 1.0134, -0.2881, 0.1141, 0.0107, 0, 0.0023

# Rescaling data:
scale_S4, scale_error_W1 = 1.1466, 0.0048
scale_W1, scale_error_W2 = 1.1712, 0.0057
scale_W2, scale_error_W4 = 1.1839, 0.0060
scale_W4, scale_error_S4 = 1.1591, 0.0087"""



sigma0r0squared, kappa0, E0r0, sigma0r0squared_error, kappa0_error, E0r0_error = 1.3496, -0.2885, -0.0031, 0.0152, 0.0125, 0.0291

sigma0oversigma_W1, kappaB_W1, E0overSqrtsigma_W1, sigma0oversigma_W1_error, kappaB_W1_error, E0overSqrtsigma_W1_error = 1.0302, -0.2881, 0.0678, 0.0485, 0, 0.0008
sigma0oversigma_W2, kappaB_W2, E0overSqrtsigma_W2, sigma0oversigma_W2_error, kappaB_W2_error, E0overSqrtsigma_W2_error = 0.9488, -0.2881, 0.2268, 0.0452, 0, 0.0018
sigma0oversigma_W4, kappaB_W4, E0overSqrtsigma_W4, sigma0oversigma_W4_error, kappaB_W4_error, E0overSqrtsigma_W4_error = 0.9687, -0.2881, 0.1962, 0.0461, 0, 0.0023
sigma0oversigma_S4, kappaB_S4, E0overSqrtsigma_S4, sigma0oversigma_S4_error, kappaB_S4_error, E0overSqrtsigma_S4_error = 0.9634, -0.2881, 0.1811, 0.0474, 0, 0.0023

# Rescaling data:
scale_S4, scale_error_W1 = 1.1496, 0.0146
scale_W1, scale_error_W2 = 1.1979, 0.0106
scale_W2, scale_error_W4 = 1.1855, 0.0120
scale_W4, scale_error_S4 = 1.1888, 0.0138

E0overSqrtsigma_S4_scaled, E0overSqrtsigma_S4_error_scaled = calculate_error(E0overSqrtsigma_S4,E0overSqrtsigma_S4_error, scale_S4, scale_error_S4, 'multiply')
E0overSqrtsigma_W1_scaled, E0overSqrtsigma_W1_error_scaled = calculate_error(E0overSqrtsigma_W1,E0overSqrtsigma_W1_error, scale_W1, scale_error_W1, 'multiply')
E0overSqrtsigma_W2_scaled, E0overSqrtsigma_W2_error_scaled = calculate_error(E0overSqrtsigma_W2,E0overSqrtsigma_W2_error, scale_W2, scale_error_W2, 'multiply')
E0overSqrtsigma_W4_scaled, E0overSqrtsigma_W4_error_scaled = calculate_error(E0overSqrtsigma_W4,E0overSqrtsigma_W4_error, scale_W4, scale_error_W4, 'multiply')

DeltaE_S4, DeltaE_S4_error = calculate_error(E0r0, E0r0_error, E0overSqrtsigma_S4_scaled, E0overSqrtsigma_S4_error_scaled, 'subtract')
DeltaE_W1, DeltaE_W1_error = calculate_error(E0r0, E0r0_error, E0overSqrtsigma_W1_scaled, E0overSqrtsigma_W1_error_scaled, 'subtract')
DeltaE_W2, DeltaE_W2_error = calculate_error(E0r0, E0r0_error, E0overSqrtsigma_W2_scaled, E0overSqrtsigma_W2_error_scaled, 'subtract')
DeltaE_W4, DeltaE_W4_error = calculate_error(E0r0, E0r0_error, E0overSqrtsigma_W4_scaled, E0overSqrtsigma_W4_error_scaled, 'subtract')


print("S4: Scale = ", np.round(scale_S4, 4), "+-", np.round(scale_error_S4, 5))
print("S4: Shift = ", np.round(DeltaE_S4, 4), "+-", np.round(DeltaE_S4_error, 5))
print("W1: Scale = ", np.round(scale_W1, 4), "+-", np.round(scale_error_W1, 5))
print("W1: Shift = ", np.round(DeltaE_W1, 4), "+-", np.round(DeltaE_W1_error, 5))
print("W2: Scale = ", np.round(scale_W2, 4), "+-", np.round(scale_error_W2, 5))
print("W2: Shift = ", np.round(DeltaE_W2, 4), "+-", np.round(DeltaE_W2_error, 5))
print("W4: Scale = ", np.round(scale_W4, 4), "+-", np.round(scale_error_W4, 5))
print("W4: Shift = ", np.round(DeltaE_W4, 4), "+-", np.round(DeltaE_W4_error, 5))

# Rescaling Bicudo's data:
Sigma_gp_BCS_S4 = rescale_Bicudo(Sigma_gp_BCS_S4, scale_S4, scale_error_S4, DeltaE_S4, DeltaE_S4_error)
Sigma_gp_BCS_W1 = rescale_Bicudo(Sigma_gp_BCS_W1, scale_W1, scale_error_W1, DeltaE_W1, DeltaE_W1_error)
Sigma_gp_BCS_W2 = rescale_Bicudo(Sigma_gp_BCS_W2, scale_W2, scale_error_W2, DeltaE_W2, DeltaE_W2_error)
Sigma_gp_BCS_W4 = rescale_Bicudo(Sigma_gp_BCS_W4, scale_W4, scale_error_W4, DeltaE_W4, DeltaE_W4_error)
Sigma_gp_prime_BCS_S4 = rescale_Bicudo(Sigma_gp_prime_BCS_S4, scale_S4, scale_error_S4, DeltaE_S4, DeltaE_S4_error)
Sigma_gp_prime_BCS_W1 = rescale_Bicudo(Sigma_gp_prime_BCS_W1, scale_W1, scale_error_W1, DeltaE_S4, DeltaE_S4_error)
Sigma_gp_prime_BCS_W2 = rescale_Bicudo(Sigma_gp_prime_BCS_W2, scale_W2, scale_error_W2, DeltaE_S4, DeltaE_S4_error)
Sigma_gp_prime_BCS_W4 = rescale_Bicudo(Sigma_gp_prime_BCS_W4, scale_W4, scale_error_W4, DeltaE_S4, DeltaE_S4_error)
Pi_u_BCS = rescale_Bicudo(Pi_u_BCS, scale_S4, scale_error_S4, DeltaE_S4, DeltaE_S4_error)
Sigma_um_BCS = rescale_Bicudo(Sigma_um_BCS, scale_S4, scale_error_S4, DeltaE_S4, DeltaE_S4_error)
Delta_g_BCS = rescale_Bicudo(Delta_g_BCS, scale_S4, scale_error_S4, DeltaE_S4, DeltaE_S4_error)
Sigma_gm_BCS = rescale_Bicudo(Sigma_gm_BCS, scale_S4, scale_error_S4, DeltaE_S4, DeltaE_S4_error)
Pi_g_BCS = rescale_Bicudo(Pi_g_BCS, scale_S4, scale_error_S4, DeltaE_S4, DeltaE_S4_error)
Pi_g_prime_BCS = rescale_Bicudo(Pi_g_prime_BCS, scale_S4, scale_error_S4, DeltaE_S4, DeltaE_S4_error)

BCS_sigma_gp = np.concatenate([Sigma_gp_BCS_S4, Sigma_gp_BCS_W1, Sigma_gp_BCS_W2, Sigma_gp_BCS_W4], axis=0)
BCS_sigma_gp_prime = np.concatenate([Sigma_gp_prime_BCS_S4, Sigma_gp_prime_BCS_W1, Sigma_gp_prime_BCS_W2, Sigma_gp_prime_BCS_W4], axis=0)





# Wagner SW:
r_SW_A = np.array([0.1863, 0.2794, 0.3726, 0.4657, 0.5589])
r_SW_B = np.array([0.1201, 0.1801, 0.2402, 0.3002, 0.3603])
r_SW_C = np.array([0.0960, 0.1441, 0.1921, 0.2401, 0.2881])
r_SW_D = np.array([0.0800, 0.1200, 0.1600, 0.2000, 0.2400, 0.2800])
r_SW_HYP2 = np.array([0.1863, 0.2794, 0.3726, 0.4657, 0.5589, 0.6520, 0.7452, 0.8383, 0.9315, 1.0246, 1.1178])

r_SW = np.concatenate([r_SW_A, r_SW_B, r_SW_C, r_SW_D, r_SW_HYP2], axis=0)
# data:
Sigma_gp_SW_A = np.array([-0.1033, 0.0929, 0.2428, 0.3726, 0.4919])
Sigma_gp_SW_B = np.array([-0.3254, -0.1227,  0.0174, 0.1292, 0.2256])
Sigma_gp_SW_C = np.array([-0.4459, -0.2326, -0.0910, 0.0176, 0.1079])
Sigma_gp_SW_D = np.array([-0.5520, -0.3260, -0.1796, -0.0706, 0.0176, 0.0930])
Sigma_gp_SW_HYP2 = np.array([-0.1112, 0.0928, 0.2430, 0.3727, 0.4923, 0.6059, 0.7159, 0.8240, 0.9308, 1.0351, 1.1345])

Sigma_gp_SW = np.concatenate([Sigma_gp_SW_A, Sigma_gp_SW_B, Sigma_gp_SW_C, Sigma_gp_SW_D, Sigma_gp_SW_HYP2], axis=0)

Pi_u_SW_A = np.array([1.2245, 1.2122, 1.2169, 1.2372, 1.2703])
Pi_u_SW_B = np.array([1.2318, 1.2127, 1.2039, 1.2035, 1.2067])
Pi_u_SW_C = np.array([1.2489, 1.2241, 1.2082, 1.2015, 1.1999])
Pi_u_SW_D = np.array([1.2754, 1.2497, 1.2337, 1.2234, 1.2173, 1.2148])
Pi_u_SW_HYP2 = np.array([1.2267, 1.2126, 1.2178, 1.2364, 1.2654, 1.3045, 1.3538, 1.4148, 1.4757, 1.5407, 1.6090])

Sigma_um_SW_A = np.array([1.2541, 1.2903, 1.3454, 1.4131, 1.4876])
Sigma_um_SW_B = np.array([1.2465, 1.2521, 1.2719, 1.3061, 1.3449])
Sigma_um_SW_C = np.array([1.2525, 1.2472, 1.2551, 1.2737, 1.2968])
Sigma_um_SW_D = np.array([1.2776, 1.2653, 1.2655, 1.2753, 1.2888, 1.3088])
Sigma_um_SW_HYP2 = np.array([1.2573, 1.2904, 1.3430, 1.4102, 1.4822, 1.5588, 1.6467, 1.7273, 1.8153, 1.9104, 2.0026])

Pi_u_SW = np.concatenate([Pi_u_SW_A, Pi_u_SW_B, Pi_u_SW_C, Pi_u_SW_D, Pi_u_SW_HYP2], axis=0)
Sigma_um_SW = np.concatenate([Sigma_um_SW_A, Sigma_um_SW_B, Sigma_um_SW_C, Sigma_um_SW_D, Sigma_um_SW_HYP2], axis=0)
# errors:
Sigma_gp_SW_errors_A = np.array([0.0024, 0.0024, 0.0024, 0.0024, 0.0025])
Sigma_gp_SW_errors_B = np.array([0.0026, 0.0024, 0.0024, 0.0024, 0.0024])
Sigma_gp_SW_errors_C = np.array([0.0028, 0.0024, 0.0024, 0.0024, 0.0024])
Sigma_gp_SW_errors_D = np.array([0.0030, 0.0025, 0.0024, 0.0024, 0.0024, 0.0024])
Sigma_gp_SW_errors_HYP2 = np.array([0.0024, 0.0023, 0.0024, 0.0024, 0.0026, 0.0028, 0.0032, 0.0037, 0.0044, 0.0054, 0.0069])

Pi_u_SW_errors_A = np.array([0.0073, 0.0076, 0.0078, 0.0081, 0.0084])
Pi_u_SW_errors_B = np.array([0.0150, 0.0149, 0.0147, 0.0147, 0.0270])
Pi_u_SW_errors_C = np.array([0.0168, 0.0165, 0.0159, 0.0095, 0.0093])
Pi_u_SW_errors_D = np.array([0.0103, 0.0109, 0.0106, 0.0104, 0.0101, 0.0099])
Pi_u_SW_errors_HYP2 = np.array([0.0058, 0.0056, 0.0058, 0.0061, 0.0066, 0.0072, 0.0079, 0.0074, 0.0079, 0.0085, 0.0091])

Sigma_um_SW_errors_A = np.array([0.0076, 0.0091, 0.0108, 0.0127, 0.0154])
Sigma_um_SW_errors_B = np.array([0.0170, 0.0183, 0.0199, 0.0220, 0.0246])
Sigma_um_SW_errors_C = np.array([0.0180, 0.0108, 0.0112, 0.0116, 0.0122])
Sigma_um_SW_errors_D = np.array([0.0113, 0.0116, 0.0118, 0.0122, 0.0127, 0.0133])
Sigma_um_SW_errors_HYP2 = np.array([0.0051, 0.0051, 0.0053, 0.0054, 0.0052, 0.0052, 0.0053, 0.0054, 0.0055, 0.0058, 0.0061])

Sigma_gp_SW_errors = np.concatenate([Sigma_gp_SW_errors_A, Sigma_gp_SW_errors_B, Sigma_gp_SW_errors_C, Sigma_gp_SW_errors_D, Sigma_gp_SW_errors_HYP2], axis=0)
Pi_u_SW_errors = np.concatenate([Pi_u_SW_errors_A, Pi_u_SW_errors_B, Pi_u_SW_errors_C, Pi_u_SW_errors_D, Pi_u_SW_errors_HYP2], axis=0)
Sigma_um_SW_errors = np.concatenate([Sigma_um_SW_errors_A, Sigma_um_SW_errors_B, Sigma_um_SW_errors_C, Sigma_um_SW_errors_D, Sigma_um_SW_errors_HYP2], axis=0)

# Wagner CPRRW:
r_CPRRW = 0.5 * np.arange(2, 13) / r0_a_W
lattice_error = 2 * hbarc * np.array([0.03529478, 0.03967817, 0.04055326, 0.04098092, 0.04207778, 0.0424421, 0.04290145, 0.04451903, 0.04530903, 0.04651875, 0.04801358])
HYP2_self_energy = 0.340
HYP2_self_energy_error = 0.002
# data:
Pi_u_CPRRW = 2 * hbarc * np.array([0.7427, 0.7369, 0.7395, 0.7483, 0.7621, 0.7805, 0.8037, 0.8326, 0.8613, 0.892, 0.9243]) * r0_a_W - HYP2_self_energy - lattice_error
Sigma_um_CPRRW = 2 * hbarc * np.array([1.2573, 1.2904, 1.3430, 1.4102, 1.4822, 1.5588, 1.6467, 1.7273, 1.8153, 1.9104, 2.0026]) * r0_a_W - HYP2_self_energy - lattice_error
Sigma_gp_prime_CPRRW = 2 * hbarc * np.array([0.902, 0.9023, 0.9155, 0.9289, 0.9465, 0.9689, 0.994, 1.0249, 1.0489, 1.0834, 1.1056]) * r0_a_W - HYP2_self_energy - lattice_error
Delta_g_CPRRW = 2 * hbarc * np.array([0.99183, 0.98505, 0.98451, 0.9863, 0.9947, 1.00777, 1.0232, 1.04199, 1.06294, 1.0865, 1.1072]) * r0_a_W - HYP2_self_energy - lattice_error
Sigma_gm_CPRRW = 2 * hbarc * np.array([1.0066, 1.0068, 1.0155, 1.0285, 1.0468, 1.07, 1.0975, 1.1282, 1.161, 1.1971, 1.235]) * r0_a_W - HYP2_self_energy - lattice_error
Pi_g_CPRRW = 2 * hbarc * np.array([0.9425, 0.9585, 0.9796, 0.996, 1.0086, 1.0216, 1.0355, 1.0528, 1.0628, 1.0837, 1.1098]) * r0_a_W - HYP2_self_energy - lattice_error
# errors:
Sigma_gp_CPRRW_errors = 2 * hbarc * np.array([0.000013, 0.000031, 0.000061, 0.00012, 0.00019, 0.00029, 0.00045, 0.00068, 0.0011, 0.0016, 0.0024]) * r0_a_W
Pi_u_CPRRW_errors = 2 * hbarc * np.array([0.0022, 0.0019, 0.0018, 0.0018, 0.0020, 0.0022, 0.0025, 0.0016, 0.0019, 0.0023, 0.0028]) * r0_a_W
Sigma_um_CPRRW_errors = 2 * hbarc * np.array([0.0051, 0.0051, 0.0053, 0.0054, 0.0052, 0.0052, 0.0053, 0.0054, 0.0055, 0.0058, 0.0061]) * r0_a_W
Sigma_gp_prime_CPRRW_errors = 2 * hbarc * np.array([0.0030, 0.0028, 0.0014, 0.0014, 0.0031, 0.0034, 0.0040, 0.0019, 0.0055, 0.0026, 0.0081]) * r0_a_W
Delta_g_CPRRW_errors = 2 * hbarc * np.array([0.00088, 0.00083, 0.00078, 0.0017, 0.0017, 0.00078, 0.00081, 0.00086, 0.00092, 0.0011, 0.0028]) * r0_a_W
Sigma_gm_CPRRW_errors = 2 * hbarc * np.array([0.00075, 0.00081, 0.00090, 0.0011, 0.00063, 0.00072, 0.00081, 0.00094, 0.0011, 0.0013, 0.0015]) * r0_a_W
Pi_g_CPRRW_errors = 2 * hbarc * np.array([0.0017, 0.0017, 0.0018, 0.0019, 0.0019, 0.0020, 0.0021, 0.0024, 0.0068, 0.0081, 0.0099]) * r0_a_W

Sigma_gp_BCS_S4[:, 0], Sigma_gp_BCS_S4[:, 2], Sigma_gp_BCS_S4[:, 3] = 0.5 * Sigma_gp_BCS_S4[:, 0], 2 * hbarc * Sigma_gp_BCS_S4[:, 2], 2 * hbarc * Sigma_gp_BCS_S4[:, 3]
Sigma_gp_BCS_W1[:, 0], Sigma_gp_BCS_W1[:, 2], Sigma_gp_BCS_W1[:, 3] = 0.5 * Sigma_gp_BCS_W1[:, 0], 2 * hbarc * Sigma_gp_BCS_W1[:, 2], 2 * hbarc * Sigma_gp_BCS_W1[:, 3]
Sigma_gp_BCS_W2[:, 0], Sigma_gp_BCS_W2[:, 2], Sigma_gp_BCS_W2[:, 3] = 0.5 * Sigma_gp_BCS_W2[:, 0], 2 * hbarc * Sigma_gp_BCS_W2[:, 2], 2 * hbarc * Sigma_gp_BCS_W2[:, 3]
Sigma_gp_BCS_W4[:, 0], Sigma_gp_BCS_W4[:, 2], Sigma_gp_BCS_W4[:, 3] = 0.5 * Sigma_gp_BCS_W4[:, 0], 2 * hbarc * Sigma_gp_BCS_W4[:, 2], 2 * hbarc * Sigma_gp_BCS_W4[:, 3]

Sigma_gp_prime_BCS_S4[:, 0], Sigma_gp_prime_BCS_S4[:, 2], Sigma_gp_prime_BCS_S4[:, 3] = 0.5 * Sigma_gp_prime_BCS_S4[:, 0], 2 * hbarc * Sigma_gp_prime_BCS_S4[:, 2], 2 * hbarc * Sigma_gp_prime_BCS_S4[:, 3]
Sigma_gp_prime_BCS_W1[:, 0], Sigma_gp_prime_BCS_W1[:, 2], Sigma_gp_prime_BCS_W1[:, 3] = 0.5 * Sigma_gp_prime_BCS_W1[:, 0], 2 * hbarc * Sigma_gp_prime_BCS_W1[:, 2], 2 * hbarc * Sigma_gp_prime_BCS_W1[:, 3]
Sigma_gp_prime_BCS_W2[:, 0], Sigma_gp_prime_BCS_W2[:, 2], Sigma_gp_prime_BCS_W2[:, 3] = 0.5 * Sigma_gp_prime_BCS_W2[:, 0], 2 * hbarc * Sigma_gp_prime_BCS_W2[:, 2], 2 * hbarc * Sigma_gp_prime_BCS_W2[:, 3]
Sigma_gp_prime_BCS_W4[:, 0], Sigma_gp_prime_BCS_W4[:, 2], Sigma_gp_prime_BCS_W4[:, 3] = 0.5 * Sigma_gp_prime_BCS_W4[:, 0], 2 * hbarc * Sigma_gp_prime_BCS_W4[:, 2], 2 * hbarc * Sigma_gp_prime_BCS_W4[:, 3]

BCS_sigma_gp = np.concatenate([Sigma_gp_BCS_S4, Sigma_gp_BCS_W1, Sigma_gp_BCS_W2, Sigma_gp_BCS_W4], axis=0)
BCS_sigma_gp_prime = np.concatenate([Sigma_gp_prime_BCS_S4, Sigma_gp_prime_BCS_W1, Sigma_gp_prime_BCS_W2, Sigma_gp_prime_BCS_W4], axis=0)

Pi_u_BCS[:, 0], Pi_u_BCS[:, 2], Pi_u_BCS[:, 3] = 0.5 * Pi_u_BCS[:, 0], 2 * hbarc * Pi_u_BCS[:, 2], 2 * hbarc * Pi_u_BCS[:, 3]
Sigma_um_BCS[:, 0], Sigma_um_BCS[:, 2], Sigma_um_BCS[:, 3] = 0.5 * Sigma_um_BCS[:, 0], 2 * hbarc * Sigma_um_BCS[:, 2], 2 * hbarc * Sigma_um_BCS[:, 3]
Delta_g_BCS[:, 0], Delta_g_BCS[:, 2], Delta_g_BCS[:, 3] = 0.5 * Delta_g_BCS[:, 0], 2 * hbarc * Delta_g_BCS[:, 2], 2 * hbarc * Delta_g_BCS[:, 3]
Sigma_gm_BCS[:, 0], Sigma_gm_BCS[:, 2], Sigma_gm_BCS[:, 3] = 0.5 * Sigma_gm_BCS[:, 0], 2 * hbarc * Sigma_gm_BCS[:, 2], 2 * hbarc * Sigma_gm_BCS[:, 3]
Pi_g_BCS[:, 0], Pi_g_BCS[:, 2], Pi_g_BCS[:, 3] = 0.5 * Pi_g_BCS[:, 0], 2 * hbarc * Pi_g_BCS[:, 2], 2 * hbarc * Pi_g_BCS[:, 3]
Pi_g_prime_BCS[:, 0], Pi_g_prime_BCS[:, 2], Pi_g_prime_BCS[:, 3] = 0.5 * Pi_g_prime_BCS[:, 0], 2 * hbarc * Pi_g_prime_BCS[:, 2], 2 * hbarc * Pi_g_prime_BCS[:, 3]
#---------------------------------------------------------







# ----------------------------------------------------------------------------------------------------------------------

def delta_V(pot1, pot2):
    pot1 = np.asarray(pot1)
    pot2 = np.asarray(pot2)
    return pot1 - pot2

def S(r_i, N, sig):
    square_root_argument = sig**2 * r_i**2 + (2 * hbarc * np.pi * sig * (N - 1/12))
    if square_root_argument >= 0:
        return np.sqrt(square_root_argument)
    else:
        return 1e3

def merge_params(opt_params, mask, fixed_values):
    full_params = []
    opt_index = 0
    for is_optimizable, fixed_value in zip(mask, fixed_values):
        if is_optimizable:
            full_params.append(opt_params[opt_index])
            opt_index += 1
        else:
            full_params.append(fixed_value)
    return full_params

def B_and_C_solver(r_0, k, A, E_s, E_l, N, sig, potential_type, S_N=None, S_1=None, S_2=None):
    if S_1 is not None and S_2 is not None:
        B = (-4*A*S_1*S_2*r_0**3 + 2*E_l*S_1*S_2*r_0 - 2*E_s*S_1*S_2*r_0 - 2*S_1**2*S_2*r_0 + 2*S_1*S_2**2*r_0
             - S_1*S_2*k + S_1*r_0**3*sig**2 - S_2*r_0**3*sig**2) / (6*S_1*S_2*r_0**5)
        C = (2*A*S_1*S_2*r_0**4 - 4*E_l*S_1*S_2*r_0**2 + 4*E_s*S_1*S_2*r_0**2 + 4*S_1**2*S_2*r_0**2
             - 4*S_1*S_2**2*r_0**2 + 5*S_1*S_2*k*r_0 + S_1*r_0**4*sig**2 - S_2*r_0**4*sig**2) / (6*S_1*S_2)
    elif S_N is not None:
        B = (-4*A*S_N*r_0**3 + 2*E_l*S_N*r_0 - 2*E_s*S_N*r_0 + 2*S_N**2*r_0 - S_N*k + r_0**3*sig**2) / (6*S_N*r_0**5)
        C = (2*A*S_N*r_0**4 - 4*E_l*S_N*r_0**2 + 4*E_s*S_N*r_0**2 - 4*S_N**2*r_0**2 + 5*S_N*k*r_0
             + r_0**4*sig**2) / (6*S_N)
    elif potential_type == "Pi_u":
        A = None
        B = (2 * E_l * S_N * r_0 - 2 * E_s * S_N * r_0 + 2 * S_N ** 2 * r_0 - S_N * k
             + r_0 ** 3 * sig ** 2) / (4 * S_N * r_0 ** 3)
        C = (-2 * E_l * S_N * r_0 ** 2 + 2 * E_s * S_N * r_0 ** 2 - 2 * S_N ** 2 * r_0 ** 2 + 3 * S_N * k * r_0
             + r_0 ** 4 * sig ** 2) / (4 * S_N)
    else:
        raise ValueError("Either S_N or S_1 and S_2 must be provided.")
    return B, C

def potential(x_values, params, N, potential_type):
    potential_function = np.zeros(len(x_values))
    r0, sig, k, A, El, Es = params
    if isinstance(N, np.ndarray) and len(N) > 1:
        S_1, S_2 = S(r0, N[0], sig), S(r0, N[1], sig)
        B, C = B_and_C_solver(r0, k, A, Es, El, N, sig, None, None, S_1, S_2)
        for i in range(len(x_values)):
            if x_values[i] <= r0:
                potential_function[i] = k / x_values[i] + Es + A * (x_values[i]**2) + B * (x_values[i]**4)
            else:
                potential_function[i] = (S(x_values[i], N[1], sig) - S(x_values[i], N[0], sig)
                                         + C / (x_values[i]**2) + El)
    elif potential_type == 'Pi_u':
        S_N_r_0 = S(r0, N[0], sig)
        B, C = B_and_C_solver(r0, k, A, Es, El, N[0], sig, None, S_N_r_0)
        for i in range(len(x_values)):
            if x_values[i] <= r0:
                potential_function[i] = k / x_values[i] + Es + A * (x_values[i]**2) + B * (x_values[i]**4)
            else:
                potential_function[i] = S(x_values[i], N[0], sig) + C / (x_values[i]**2) + El
    else:
        S_N_r_0 = S(r0, N[0], sig)
        B, C = B_and_C_solver(r0, k, A, Es, El, N[0], sig, 'Pi_u', S_N_r_0, S_1=None, S_2=None)
        for i in range(len(x_values)):
            if x_values[i] <= r0:
                potential_function[i] = k / x_values[i] + Es + B * (x_values[i]**2)
            else:
                potential_function[i] = S(x_values[i], N[0], sig) + C / (x_values[i]**2) + El
    return potential_function
def calculate_rms(r, params, N, lattice_data, potential_type):
    python_pot = potential(r, params, N, potential_type)
    delta = python_pot - lattice_data
    rms = np.sqrt(np.mean(delta**2))
    return 1e3 * rms

def fit_pot(R, potential_name, lattice_data, errors, N, mask, fixed_values, potential_type=None):
    if len(R)>1:
        r = np.concatenate(R, axis=0)
        data = np.concatenate(lattice_data, axis=0)
        errors = np.concatenate(errors, axis=0)
    else:
        r = R[0]
        data = lattice_data[0]
        errors = errors[0]
    potential_name = fr"$\{potential_name}$"
    def objective_function_with_mask(r, *opt_params):
        full_params = merge_params(opt_params, mask, fixed_values)
        return potential(r, full_params, N, potential_type)
    bounds_lower = [0] + [-np.inf for _ in range(sum(mask) - 1)]
    bounds_upper = [np.inf] + [np.inf for _ in range(sum(mask) - 1)]
    bounds = (bounds_lower, bounds_upper)
    opt_params_initial = [1 if i == 0 else fixed_values[i] for i, m in enumerate(mask) if m]
    opt_params, cov = curve_fit(objective_function_with_mask, r, data, sigma=errors,
                                absolute_sigma=True, p0=opt_params_initial, bounds=bounds, maxfev=1000000)
    full_params = merge_params(opt_params, mask, fixed_values)
    perr = np.sqrt(np.diag(cov))
    full_perr = np.zeros_like(full_params)
    j = 0
    for i, m in enumerate(mask):
        if m:
            full_perr[i] = perr[j]
            j += 1
    fitted_potential = potential(x, full_params, N, potential_type)
    rms = calculate_rms(r, full_params, N, data, potential_type)
    labels = [r"$r_0$", r"$\sigma$", r"$\kappa$", "A", r"$E_l$", r"$E_s$"]
    text_str = f"Potential: {potential_name}\n"
    text_str += "\n".join(
        [f"{label} = ${param:.4f} \pm {error:.5f}$" for label, param, error in zip(labels, full_params, full_perr)])
    text_str += f"\nRMS error = {rms:.2f}"

    # Create a figure
    fig, ax = plt.subplots()
    ax.axis('off')  # Turn off the axis

    # Place the text on the plot
    ax.text(0.05, 0.95, text_str, fontsize=12, va='top', transform=ax.transAxes)

    plt.show()

    return fitted_potential

def plot_pot(R, labels, markers, filling, colors, lattice_data_set, lattice_data_errors, fitted_potential,
             fitted_potential_labels):
    y_datasets = [[labels[i], lattice_data_set[i]] for i in range(len(labels))]
    plt.figure(figsize=(1.168*15, 15))
    for i in range(len(y_datasets)):
        plt.errorbar(R[i], lattice_data_set[i], yerr=lattice_data_errors[i], fmt=markers[i], color=colors[i],
                     fillstyle=filling[i], label=fr'${{\{labels[i]}}}$', markersize=10, capsize=0, markeredgewidth=1.8)
    #for i in range(len(fitted_potential)):
        #plt.plot(x, fitted_potential[i], color='black', label=fr'$V_{{\{fitted_potential_labels[i]}}}$',
                 #linewidth=3)
    plt.xlabel(r'$r~(fm)$', fontsize=45)
    plt.ylabel(r'$V~(GeV)$', fontsize=45)
    #--plt.legend(fontsize=25)
    legend = plt.legend(fontsize=25, loc='lower right')
    legend.set_frame_on(False)
    #--plt.grid(True, which='both', linestyle='--', linewidth=0.5)


    plt.margins(x=0, y=0)
    plt.xlim(0, x[-1])
    plt.ylim(-1, max(fitted_potential[-1]))
    ax = plt.gca()
    ax.set_xticks([0, 0.5, 1, 1.5, 2])
    ax.set_yticks([-1, -0.5, 0, 0.5, 1, 1.5, 2])

    ax.xaxis.set_minor_locator(AutoMinorLocator(4))
    ax.yaxis.set_minor_locator(AutoMinorLocator(4))

    """plt.margins(x=0, y=0)
    plt.xlim(0, x[-1])
    plt.ylim(1, max(fitted_potential[-1]))
    ax = plt.gca()
    ax.set_xticks([0, 0.5, 1, 1.5, 2])
    ax.set_yticks([1, 1.5, 2, 2.5])

    ax.xaxis.set_minor_locator(AutoMinorLocator(4))
    ax.yaxis.set_minor_locator(AutoMinorLocator(4))"""


    """plt.margins(x=0, y=0)
    plt.xlim(0, x[-1])
    plt.ylim(1.6, max(fitted_potential[-1]))
    ax = plt.gca()
    ax.set_xticks([0, 0.5, 1, 1.5, 1.8])
    ax.set_yticks([1.6, 2, 2.5, 3])"""




    ax.tick_params(axis='x', which='both', top=True, bottom=True, labeltop=False, labelbottom=True, labelsize=33,
                   length=15, width=4, direction='in', pad=14)
    ax.tick_params(axis='y', which='both', left=True, right=True, labelleft=True, labelright=False, labelsize=33,
                   length=15, width=4, direction='in', pad=14)

    ax.tick_params(axis='y', which='minor', left=True, right=True, labelleft=False, labelright=False,
                   length=8, width=2, direction='in')
    ax.tick_params(axis='x', which='minor', left=True, right=True, labelleft=False, labelright=False,
                   length=8, width=2, direction='in')

    x_labels = ax.get_xticklabels()
    y_labels = ax.get_yticklabels()
    if y_labels:
        y_labels[0].set_visible(False)
        x_labels[-1].set_visible(False)
        y_labels[-1].set_visible(False)
    ax.spines['top'].set_linewidth(4)
    ax.spines['bottom'].set_linewidth(4)
    ax.spines['left'].set_linewidth(4)
    ax.spines['right'].set_linewidth(4)
    plt.show()


def execute_code():
    r_SW_all = np.concatenate([r_SW_A, r_SW_B, r_SW_C, r_SW_D], axis=0)
    Sigma_gp_SW_all = np.concatenate([Sigma_gp_SW_A, Sigma_gp_SW_B, Sigma_gp_SW_C, Sigma_gp_SW_D], axis=0)
    Sigma_gp_SW_errors_all = np.concatenate([Sigma_gp_SW_errors_A, Sigma_gp_SW_errors_B, Sigma_gp_SW_errors_C, Sigma_gp_SW_errors_D], axis=0)
    Pi_u_SW_all = np.concatenate([Pi_u_SW_A, Pi_u_SW_B, Pi_u_SW_C, Pi_u_SW_D], axis=0)
    Pi_u_SW_errors_all = np.concatenate([Pi_u_SW_errors_A, Pi_u_SW_errors_B, Pi_u_SW_errors_C, Pi_u_SW_errors_D], axis=0)
    Sigma_um_SW_all = np.concatenate([Sigma_um_SW_A, Sigma_um_SW_B, Sigma_um_SW_C, Sigma_um_SW_D], axis=0)
    Sigma_um_SW_errors_all = np.concatenate([Sigma_um_SW_errors_A, Sigma_um_SW_errors_B, Sigma_um_SW_errors_C, Sigma_um_SW_errors_D], axis=0)
    Sigma_gp_BCS_Ws = np.concatenate([Sigma_gp_BCS_W1, Sigma_gp_BCS_W2, Sigma_gp_BCS_W4], axis=0)
    Sigma_gp_prime_BCS_Ws = np.concatenate([Sigma_gp_prime_BCS_W1, Sigma_gp_prime_BCS_W2, Sigma_gp_prime_BCS_W4], axis=0)


    #Sigma_gp:
    r_values = [r_SW_all, r_SW_HYP2, Sigma_gp_BCS_S4[:, 0], Sigma_gp_BCS_Ws[:, 0]]
    data = [Sigma_gp_SW_all, Sigma_gp_SW_HYP2, Sigma_gp_BCS_S4[:, 2],
        Sigma_gp_BCS_Ws[:, 2]]
    errors = [Sigma_gp_SW_errors_all,
        Sigma_gp_SW_errors_HYP2, Sigma_gp_BCS_S4[:, 3], Sigma_gp_BCS_Ws[:, 3]]

    Sigma_gp = fit_pot(r_values, "Sigma_{gW}^+", data, errors,
        np.array([0.0]), [True, True, True, False, False, True],
        np.array([1, 1, 0, 0, 0, 0]), "Pi_u")
    plot_pot(r_values, [r"Sigma_{g(A, B, C, D)}^+",
        r"Sigma_{g(HYP2)}^+", r"Sigma_{g(S_4)}^+", r"Sigma_{g(W_1, W_2, W_4)}^+"],
        ['o', 'o', 's', 's'],
        ['none', 'full', 'full', 'none'],
        [my_green, my_green, my_blue, my_blue], data, errors,
        [Sigma_gp],["Sigma_g^+"])

    # Pi_u & Sigma_um:
    r_pi_u = [r_SW_all, r_SW_HYP2, Pi_u_BCS[:, 0]]
    data_pi_u = [Pi_u_SW_all, Pi_u_SW_HYP2, Pi_u_BCS[:, 2]]
    errors_pi_u = [Pi_u_SW_errors_all, Pi_u_SW_errors_HYP2 , Pi_u_BCS[:, 3]]

    r_sigma_um = [r_SW_all, r_SW_HYP2, Sigma_um_BCS[:, 0]]
    data_sigma_um = [delta_V(Sigma_um_SW_all, Pi_u_SW_all), delta_V(Sigma_um_SW_HYP2, Pi_u_SW_HYP2), delta_V(Sigma_um_BCS[:, 2], Pi_u_BCS[:, 2])]
    errors_sigma_um = [add_errors(Sigma_um_SW_errors_all, Pi_u_SW_errors_all), add_errors(Sigma_um_SW_errors_HYP2, Pi_u_SW_errors_HYP2), add_errors(Sigma_um_BCS[:, 3], Pi_u_BCS[:, 3])]

    Pi_u = fit_pot(r_pi_u, "Pi_u", data_pi_u, errors_pi_u,
                   np.array([1.0]), [True, True, True, False, True, True], np.array([0, 1, 0, 0, 0, 0]), "Pi_u")

    Pi_u_new = fit_pot([r_CPRRW], "Pi_u", [Pi_u_CPRRW], [Pi_u_CPRRW_errors],
                   np.array([1.0]), [True, True, True, False, True, True], np.array([0, 1, 0, 0, 0, 0]), "Pi_u")

    sig_um = fit_pot(r_sigma_um, "Sigma_u^-", data_sigma_um, errors_sigma_um,
                        np.array([1.0, 3.0]), [True, True, False, True, True, False], np.array([0, 1, 0, 0, 0, 0]), "Sigma_u")

    plot_pot([r_SW_all, r_SW_HYP2, Pi_u_BCS[:, 0], r_SW_all, r_SW_HYP2,  Sigma_um_BCS[:, 0]], [r"Pi_{u(A, B, C, D)}", r"Pi_{u(HYP2)}", r"Pi_{u(S_4)}", r"Sigma_{u(A, B, C, D)}^-", r"Sigma_{u(HYP2)}^-", r"Sigma_{u(S_4)}^-"], ['o', 'o', 's', '^', '^', 'v'], ['none', 'full', 'full', 'none', 'full', 'full'], [my_blue, my_blue, my_green, my_blue, my_blue, my_green], [Pi_u_SW_all, Pi_u_SW_HYP2, Pi_u_BCS[:, 2], Sigma_um_SW_all, Sigma_um_SW_HYP2, Sigma_um_BCS[:, 2]], [Pi_u_SW_errors_all, Pi_u_SW_errors_HYP2, Pi_u_BCS[:, 3], Sigma_um_SW_errors_all, Sigma_um_SW_errors_HYP2 , Sigma_um_BCS[:, 3]], [Pi_u, sig_um+Pi_u], ["Pi_u", "Sigma_g^+'"])

    # Sigma_gpprime & Pi_g:
    sig_gpprime = fit_pot([r_CPRRW, Sigma_gp_prime_BCS_S4[:, 0]], "Sigma_g^+'", [delta_V(Sigma_gp_prime_CPRRW, Pi_u_CPRRW), delta_V(Sigma_gp_prime_BCS_S4[:, 2], Pi_u_BCS[:, 2])], [add_errors(Sigma_gp_prime_CPRRW_errors, Pi_u_CPRRW_errors), add_errors(Sigma_gp_prime_BCS_S4[:, 3], Pi_u_BCS[:, 3])],
                        np.array([1.0, 2.0]), [True, True, False, True, True, True], np.array([0, 1, 0, 0, 0, 0]), "Sigma_gpp")

    pi_g = fit_pot([r_CPRRW, Pi_g_BCS[:, 0]], "Pi_g", [delta_V(Pi_g_CPRRW, Pi_u_CPRRW), delta_V(Pi_g_BCS[:, 2], Pi_u_BCS[:, 2])], [add_errors(Pi_g_CPRRW_errors, Pi_u_CPRRW_errors), add_errors(Pi_g_BCS[:, 3], Pi_u_BCS[:, 3])],
                        np.array([1.0, 2.0]), [True, True, False, True, True, True], np.array([0, 1, 0, 0, 0, 0]), "Pi_g")

    plot_pot([r_CPRRW, Pi_g_BCS[:, 0], r_CPRRW, Sigma_gp_prime_BCS_S4[:, 0], Sigma_gp_prime_BCS_Ws[:, 0]], [r"Pi_{g(HYP2)}", r"Pi_{g(S_4)}", r"Sigma_{g(HYP2)}^+'", r"Sigma_{g(S_4)}^+'", r"Sigma_{g(W_1, W_2, W_4)}^+'"], ['o', 's', '^', 'v', 'v'], ['full', 'full', 'full', 'full', 'none'], [my_green, my_blue, my_green, my_blue, my_blue], [Pi_g_CPRRW, Pi_g_BCS[:, 2], Sigma_gp_prime_CPRRW, Sigma_gp_prime_BCS_S4[:, 2], Sigma_gp_prime_BCS_Ws[:, 2]], [Pi_g_CPRRW_errors, Pi_g_BCS[:, 3], Sigma_gp_prime_CPRRW_errors, Sigma_gp_prime_BCS_S4[:, 3], Sigma_gp_prime_BCS_Ws[:, 3]], [pi_g+Pi_u_new, sig_gpprime+Pi_u_new], ["Pi_g", "Sigma_g^+'"])

    # Delta_g & Sigma_gm & Pi_g:
    delta_g = fit_pot([r_CPRRW, Delta_g_BCS[:, 0]], "Delta_g", [delta_V(Delta_g_CPRRW, Pi_u_CPRRW), delta_V(Delta_g_BCS[:, 2], Pi_u_BCS[:, 2])], [add_errors(Delta_g_CPRRW_errors, Pi_u_CPRRW_errors), add_errors(Delta_g_BCS[:, 3], Pi_u_BCS[:, 3])],
                        np.array([1.0, 2.0]), [True, True, False, True, True, True], np.array([0, 1, 0, 0, 0, 0]), "delta_g")

    sig_gm = fit_pot([r_CPRRW, Sigma_gm_BCS[:, 0]], "Sigma_g^-", [delta_V(Sigma_gm_CPRRW, Delta_g_CPRRW), delta_V(Sigma_gm_BCS[:, 2], Sigma_gm_BCS[:, 2])], [add_errors(Sigma_gm_CPRRW_errors, Delta_g_CPRRW_errors), add_errors(Sigma_gm_BCS[:, 3], Sigma_gm_BCS[:, 3])],
                        np.array([2.0, 4.0]), [True, True, False, True, True, False], np.array([0, 1, 0, 0, 0, 0]), "Sigma_gm")
    pi_gprime = fit_pot([Pi_g_prime_BCS[:, 0]], "Pi_g'", [delta_V(Pi_g_prime_BCS[:, 2], Delta_g_BCS[:, 2])], [add_errors(Pi_g_prime_BCS[:, 3], Delta_g_BCS[:, 3])],
                        np.array([2.0, 4.0]), [True, True, True, False, True, True], np.array([0, 1, 0, 0, 0, 0]), "Pi_u")

    plot_pot([Pi_g_prime_BCS[:, 0], r_CPRRW, Delta_g_BCS[:, 0], r_CPRRW, Sigma_gm_BCS[:, 0]], [r"Pi_{g(S_4)}'", r"Delta_{g(HYP2)}", r"Delta_{g(S_4)}", "Sigma_{g(HYP2)}^-", "Sigma_{g(S_4)}^-"], ['x', 'o', 's', '^', 'v'], ['full', 'full', 'full', 'full', 'full'], [my_blue, my_green, my_blue, my_green, my_blue], [Pi_g_prime_BCS[:, 2], Delta_g_CPRRW, Delta_g_BCS[:, 2], Sigma_gm_CPRRW, Sigma_gm_BCS[:, 2]], [Pi_g_prime_BCS[:, 3], Delta_g_CPRRW_errors, Delta_g_BCS[:, 3], Sigma_gm_CPRRW_errors, Sigma_gm_BCS[:, 3]], [pi_gprime+delta_g+Pi_u_new, delta_g+Pi_u_new, sig_gm+delta_g+Pi_u_new], ["Pi_g'", "Delta_g", "Sigma_g^-"])


execute_code()

